unem         = unem,
strong_idx   = strong_idx,
horizon_list = h_pred,
p2           = 1,
lambda_start = 0.3,
max_iter     = 40,
sd_min       = 1e-4,
jitter_sd    = 1e-6,
verbose      = TRUE
)
df_new_updated <- res$df_new
###############################################################
## Build updated surrogate matrix
###############################################################
df_summary_updated <- df_new_updated %>%
group_by(month, period) %>%
summarise(pred_score = mean(pred_score, na.rm = TRUE),
.groups = "drop")
tilde_y_m_updated <- df_summary_updated %>%
tidyr::pivot_wider(
id_cols = month,
names_from = period,
values_from = pred_score
) %>%
arrange(month) %>%
select(up, middle, down) %>%
as.matrix()
###############################################################
## Output files
###############################################################
write.csv(df_new_updated, "df_new_updated.csv", row.names = FALSE)
write.csv(tilde_y_m_updated, "tilde_y_m_updated.csv", row.names = FALSE)
knitr::opts_chunk$set(echo = TRUE)
# setwd("/Users/sunao/Desktop/LLM-TS-Revision/code/real_data")
# setwd("/Users/sunao/Desktop/LLM-TS-Revision/code/real_data/Weibo-final/")
source("./utility.R")
library(lubridate)
set.seed(2025)
# simple helpers used later in the Rmd
Average_prediction <- function(y, H) {
sapply(seq_len(H), function(h) mean(tail(y, h)))
}
check_coverage <- function(interval_row, true_val) {
as.integer(true_val >= interval_row[1] & true_val <= interval_row[2])
}
target_var <- params$target_var
macro_raw <- read.csv("./2025-10-MD.csv", stringsAsFactors = FALSE, check.names = FALSE)
macro_raw$sasdate <- suppressWarnings(as.Date(macro_raw[[1]], format = "%m/%d/%Y"))
macro_raw <- macro_raw[!is.na(macro_raw$sasdate), ]
# base_info <- read.csv("./topics_with_pred_score_final.csv") %>%
#   select(date, pred_score, UNRATE)
base_info <- read.csv("./df_new_updated.csv") %>%
select(date, pred_score, UNRATE)
topics_df <- read.csv("./daily_topic_10topics.csv")
df <- topics_df %>%
left_join(base_info, by = "date") %>%
mutate(date = as.Date(date)) %>%
filter(date < as.Date("2025-09-01"), date > as.Date("2015-08-31")) %>%
arrange(date) %>%
mutate(
month = format(date, "%Y-%m"),
day = day(date),
period = case_when(
day <= 10 ~ "up",
day <= 20 ~ "middle",
TRUE ~ "down"
)
)
df_summary <- df %>%
group_by(month, period) %>%
summarise(across(everything(), \(x) mean(x, na.rm = TRUE)), .groups = "drop")
y_m_list <- sort(unique(df_summary$month))
month_dates <- as.Date(paste0(y_m_list, "-01"))
tilde_y_m <- matrix(ncol = 3, nrow = length(y_m_list))
for (i in seq_along(y_m_list)) {
res_ym <- y_m_list[i]
tilde_y_m[i, ] <- df_summary[df_summary$month == res_ym, ]$pred_score
}
#tilde_y_m <- scale(tilde_y_m)
topic_cols <- names(df_summary)[grepl("^topic", names(df_summary))]
X_m <- matrix(ncol = length(topic_cols), nrow = length(y_m_list))
for (i in seq_along(y_m_list)) {
res_ym <- y_m_list[i]
X_m[i, ] <- apply(df_summary[df_summary$month == res_ym, topic_cols], 2, mean)
}
X_m <- scale(X_m)
colnames(X_m) <- topic_cols
topic_dates <- df$date
topic_months <- df$month
unrate_monthly <- df %>%
group_by(month) %>%
summarise(unrate = mean(UNRATE, na.rm = TRUE), .groups = "drop") %>%
filter(month %in% y_m_list)
unem <- scale(unrate_monthly$unrate)
has_unem <- TRUE
m_dates <- macro_raw$sasdate
if (!target_var %in% names(macro_raw)) {
stop(paste("Target variable not found in 2025-10-MD.csv:", target_var))
}
m_vals <- macro_raw[[target_var]]
ptr <- 1
current <- NA_real_
target_series <- numeric(length(topic_dates))
for (i in seq_along(topic_dates)) {
t_d <- topic_dates[i]
while (ptr <= length(m_dates) && m_dates[ptr] <= t_d) {
current <- m_vals[ptr]
ptr <- ptr + 1
}
target_series[i] <- current
}
y_df <- data.frame(month = topic_months, y = target_series) %>%
group_by(month) %>%
summarise(y = mean(y, na.rm = TRUE), .groups = "drop") %>%
filter(month %in% y_m_list)
y_raw <- y_df$y
y_ratio <- c(1, y_raw[-1] / y_raw[-length(y_raw)])
y_center <- mean(y_ratio, na.rm = TRUE)
y_scale <- sd(y_ratio, na.rm = TRUE)
y <- (y_ratio - y_center) / y_scale
#EOD <- min(64, nrow(X_m)) # use up-to 2024-04 data points to select the important variables
EOD <- max(which(month_dates < as.Date("2024-07-01")))
sel <- select_topics(y, X_m, train_idx = 1:EOD, use_cor = FALSE, penalty_w = 0.1)
strong_idx <- match(sel$selected, colnames(X_m))
strong_idx <- strong_idx[!is.na(strong_idx)]
if (length(strong_idx) == 0) {
strong_idx <- 1
}
strong_idx
h_pred <- seq(5,12,1)
Res_m <- matrix(nrow = length(h_pred), ncol = 20)
for(k in seq_along(h_pred)){
h <- h_pred[k]
res_c <- NULL
test_idx <- (length(y) - h + 1):length(y)
obs_idx <- setdiff(seq_along(y), test_idx)
# AR
ar_base <- auto.arima(y[obs_idx],max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE, allowdrift = FALSE)
p1 <- max(1, ar_base$arma[1])
ar_fit <- arima(y[obs_idx], order = c(p1,0,0), include.mean = FALSE)
ar_prediction <- predict(ar_fit, n.ahead = h)$pred
res_c <- c(res_c, sqrt(mean((ar_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(ar_prediction) !=sign(y[test_idx])))
#random walk
mean_prediction <- rep(y[max(obs_idx)], length(test_idx))
res_c <- c(res_c, sqrt(mean((mean_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(mean_prediction) !=sign(y[test_idx])))
#Average
ave_prediction <- Average_prediction(y[obs_idx], length(test_idx))
res_c <- c(res_c, sqrt(mean((ave_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(ave_prediction) !=sign(y[test_idx])))
#AR + unemployment
ar_unem_base <- auto.arima(y[obs_idx], xreg = unem[obs_idx], max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE,      allowdrift = FALSE)
p1_un <- max(1, ar_unem_base$arma[1])
ar_unem_fit <- arima(y[obs_idx], xreg = unem[obs_idx], order = c(p1_un,0,0), include.mean = FALSE)
ar_unem_prediction <- predict(ar_unem_fit, newxreg = unem[test_idx], n.ahead = h)$pred
res_c <- c(res_c, sqrt(mean((ar_unem_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(ar_unem_prediction) !=sign(y[test_idx])))
#AR + LDA embedding
arx_fit <- arima(y[obs_idx], order = c(p1,0,0), xreg = X_m[obs_idx,strong_idx, drop = FALSE], include.mean = FALSE)
arx_predictions <- predict(arx_fit, n.ahead = h, newxreg = X_m[test_idx,strong_idx, drop = FALSE])$pred
res_c <- c(res_c, sqrt(mean((arx_predictions-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(arx_predictions) !=sign(y[test_idx])))
# AR + unem + LDA embedding
arx_unem_fit <- arima(y[obs_idx],order = c(p1,0,0), xreg = cbind(X_m[obs_idx,strong_idx, drop=FALSE],unem[obs_idx]), include.mean = FALSE)
arx_unem_predictions <- predict(arx_unem_fit, n.ahead=h, newxreg=cbind(X_m[test_idx,strong_idx,drop=FALSE],  unem[test_idx]))$pred
res_c <- c(res_c, sqrt(mean((arx_unem_predictions-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(arx_unem_predictions) !=sign(y[test_idx])))
# LLM powered: lag term + LDA embedding
p2=1
powered_prediction <- LLM_TS.Predict(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, strong_idx, h)
res_c <- c(res_c, sqrt(mean((powered_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(powered_prediction) !=sign(y[test_idx])))
# LLM powered: lag term + unem + LDA embedding
powered_unem_prediction <- LLM_TS.Predict(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx,
c(strong_idx,ncol(X_m)+1), h)
res_c <- c(res_c, sqrt(mean((powered_unem_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(powered_unem_prediction) !=sign(y[test_idx])))
# TimeLLM (CPI only) - not available for WSJ yet
res_c <- c(res_c, NA_real_, NA_real_)
# PatchTST (CPI only) - not available for WSJ yet
res_c <- c(res_c, NA_real_, NA_real_)
Res_m[k,] <- res_c
}
LDA_mse <- Res_m[,seq(1, ncol(Res_m), 2)]
LDA_sign <- Res_m[,seq(2, ncol(Res_m), 2)]
colnames(LDA_mse) <- c('AR','RW','AVE','AR+unem','LDA','LDA+unem','LLM+LDA','LLM+LDA+unem',
'TimeLLM','PatchTST')
colnames(LDA_sign) <- c('AR','RW','AVE','AR+unem','LDA','LDA+unem','LLM+LDA','LLM+LDA+unem',
'TimeLLM','PatchTST')
MSE_without_unem <- LDA_mse[,c('AR','RW','AVE','LDA','LLM+LDA','TimeLLM','PatchTST')]
rMSE_without_unem <- sweep(MSE_without_unem, 1, MSE_without_unem[,'AR',drop=FALSE], "/")
rMSE_without_unem <- cbind(h_pred, rMSE_without_unem)
knitr::kable(rMSE_without_unem,col.names = c('H','AR','RW','AVE','LDA','LLM+LDA','TimeLLM','PatchTST'), digits = 3, caption = 'Cumulative rPMSE without unemployment rate')
colMeans(rMSE_without_unem[,-1, drop = FALSE])
#!/usr/bin/env Rscript
###############################################################
## wsj_run_change_score.R
## Runs robust universal surrogate optimization
###############################################################
source("utility.R")
source("wsj_build_data.R")
source("change_score_wsj_strict.R")
###############################################################
## Load data
###############################################################
data_list <- wsj_build_data()
df         <- data_list$df
df_summary <- data_list$df_summary
tilde_y_m  <- data_list$tilde_y_m
X_m        <- data_list$X_m
unem       <- data_list$unem
y_list     <- data_list$y_list
strong_idx <- data_list$strong_idx
y_m_list   <- data_list$y_m_list
h_pred <- 5:12
cat("=== Running universal surrogate optimization ===\n")
###############################################################
## Optimize surrogate
###############################################################
res <- change_pred_score_multi(
df_new       = df,
y_list       = y_list,
X_m          = X_m,
unem         = unem,
strong_idx   = strong_idx,
horizon_list = h_pred,
p2           = 1,
lambda_start = 0.3,
max_iter     = 40,
sd_min       = 1e-4,
jitter_sd    = 1e-6,
verbose      = TRUE
)
#!/usr/bin/env Rscript
###############################################################
## wsj_run_change_score.R
## Runs robust universal surrogate optimization
###############################################################
source("utility.R")
source("wsj_build_data.R")
source("change_score_wsj_strict.R")
###############################################################
## Load data
###############################################################
data_list <- wsj_build_data()
df         <- data_list$df
df_summary <- data_list$df_summary
tilde_y_m  <- data_list$tilde_y_m
X_m        <- data_list$X_m
unem       <- data_list$unem
y_list     <- data_list$y_list
strong_idx <- data_list$strong_idx
y_m_list   <- data_list$y_m_list
h_pred <- 5:12
cat("=== Running universal surrogate optimization ===\n")
###############################################################
## Optimize surrogate
###############################################################
res <- change_pred_score_multi(
df_new       = df,
y_list       = y_list,
X_m          = X_m,
unem         = unem,
strong_idx   = strong_idx,
horizon_list = h_pred,
p2           = 1,
lambda_start = 0.3,
max_iter     = 40,
sd_min       = 1e-4,
jitter_sd    = 1e-6,
verbose      = TRUE
)
#!/usr/bin/env Rscript
###############################################################
## wsj_run_change_score.R
## Runs robust universal surrogate optimization
###############################################################
source("utility.R")
source("wsj_build_data.R")
source("change_score_wsj_strict.R")
###############################################################
## Load data
###############################################################
data_list <- wsj_build_data()
df         <- data_list$df
df_summary <- data_list$df_summary
tilde_y_m  <- data_list$tilde_y_m
X_m        <- data_list$X_m
unem       <- data_list$unem
y_list     <- data_list$y_list
strong_idx <- data_list$strong_idx
y_m_list   <- data_list$y_m_list
h_pred <- 5:12
cat("=== Running universal surrogate optimization ===\n")
###############################################################
## Optimize surrogate
###############################################################
res <- change_pred_score_multi(
df_new       = df,
y_list       = y_list,
X_m          = X_m,
unem         = unem,
strong_idx   = strong_idx,
horizon_list = h_pred,
p2           = 1,
lambda_start = 0.3,
max_iter     = 40,
sd_min       = 1e-4,
jitter_sd    = 1e-6,
verbose      = TRUE
)
df_new_updated <- res$df_new
###############################################################
## Build updated surrogate matrix
###############################################################
df_summary_updated <- df_new_updated %>%
group_by(month, period) %>%
summarise(pred_score = mean(pred_score, na.rm = TRUE),
.groups = "drop")
tilde_y_m_updated <- df_summary_updated %>%
tidyr::pivot_wider(
id_cols = month,
names_from = period,
values_from = pred_score
) %>%
arrange(month) %>%
select(up, middle, down) %>%
as.matrix()
###############################################################
## Output files
###############################################################
write.csv(df_new_updated, "df_new_updated.csv", row.names = FALSE)
write.csv(tilde_y_m_updated, "tilde_y_m_updated.csv", row.names = FALSE)
knitr::opts_chunk$set(echo = TRUE)
# setwd("/Users/sunao/Desktop/LLM-TS-Revision/code/real_data")
# setwd("/Users/sunao/Desktop/LLM-TS-Revision/code/real_data/Weibo-final/")
source("./utility.R")
library(lubridate)
set.seed(2025)
# simple helpers used later in the Rmd
Average_prediction <- function(y, H) {
sapply(seq_len(H), function(h) mean(tail(y, h)))
}
check_coverage <- function(interval_row, true_val) {
as.integer(true_val >= interval_row[1] & true_val <= interval_row[2])
}
target_var <- params$target_var
macro_raw <- read.csv("./2025-10-MD.csv", stringsAsFactors = FALSE, check.names = FALSE)
macro_raw$sasdate <- suppressWarnings(as.Date(macro_raw[[1]], format = "%m/%d/%Y"))
macro_raw <- macro_raw[!is.na(macro_raw$sasdate), ]
# base_info <- read.csv("./topics_with_pred_score_final.csv") %>%
#   select(date, pred_score, UNRATE)
base_info <- read.csv("./df_new_updated.csv") %>%
select(date, pred_score, UNRATE)
topics_df <- read.csv("./daily_topic_10topics.csv")
df <- topics_df %>%
left_join(base_info, by = "date") %>%
mutate(date = as.Date(date)) %>%
filter(date < as.Date("2025-09-01"), date > as.Date("2015-08-31")) %>%
arrange(date) %>%
mutate(
month = format(date, "%Y-%m"),
day = day(date),
period = case_when(
day <= 10 ~ "up",
day <= 20 ~ "middle",
TRUE ~ "down"
)
)
df_summary <- df %>%
group_by(month, period) %>%
summarise(across(everything(), \(x) mean(x, na.rm = TRUE)), .groups = "drop")
y_m_list <- sort(unique(df_summary$month))
month_dates <- as.Date(paste0(y_m_list, "-01"))
tilde_y_m <- matrix(ncol = 3, nrow = length(y_m_list))
for (i in seq_along(y_m_list)) {
res_ym <- y_m_list[i]
tilde_y_m[i, ] <- df_summary[df_summary$month == res_ym, ]$pred_score
}
#tilde_y_m <- scale(tilde_y_m)
topic_cols <- names(df_summary)[grepl("^topic", names(df_summary))]
X_m <- matrix(ncol = length(topic_cols), nrow = length(y_m_list))
for (i in seq_along(y_m_list)) {
res_ym <- y_m_list[i]
X_m[i, ] <- apply(df_summary[df_summary$month == res_ym, topic_cols], 2, mean)
}
X_m <- scale(X_m)
colnames(X_m) <- topic_cols
topic_dates <- df$date
topic_months <- df$month
unrate_monthly <- df %>%
group_by(month) %>%
summarise(unrate = mean(UNRATE, na.rm = TRUE), .groups = "drop") %>%
filter(month %in% y_m_list)
unem <- scale(unrate_monthly$unrate)
has_unem <- TRUE
m_dates <- macro_raw$sasdate
if (!target_var %in% names(macro_raw)) {
stop(paste("Target variable not found in 2025-10-MD.csv:", target_var))
}
m_vals <- macro_raw[[target_var]]
ptr <- 1
current <- NA_real_
target_series <- numeric(length(topic_dates))
for (i in seq_along(topic_dates)) {
t_d <- topic_dates[i]
while (ptr <= length(m_dates) && m_dates[ptr] <= t_d) {
current <- m_vals[ptr]
ptr <- ptr + 1
}
target_series[i] <- current
}
y_df <- data.frame(month = topic_months, y = target_series) %>%
group_by(month) %>%
summarise(y = mean(y, na.rm = TRUE), .groups = "drop") %>%
filter(month %in% y_m_list)
y_raw <- y_df$y
y_ratio <- c(1, y_raw[-1] / y_raw[-length(y_raw)])
y_center <- mean(y_ratio, na.rm = TRUE)
y_scale <- sd(y_ratio, na.rm = TRUE)
y <- (y_ratio - y_center) / y_scale
#EOD <- min(64, nrow(X_m)) # use up-to 2024-04 data points to select the important variables
EOD <- max(which(month_dates < as.Date("2024-07-01")))
sel <- select_topics(y, X_m, train_idx = 1:EOD, use_cor = FALSE, penalty_w = 0.1)
strong_idx <- match(sel$selected, colnames(X_m))
strong_idx <- strong_idx[!is.na(strong_idx)]
if (length(strong_idx) == 0) {
strong_idx <- 1
}
strong_idx
h_pred <- seq(5,12,1)
Res_m <- matrix(nrow = length(h_pred), ncol = 20)
for(k in seq_along(h_pred)){
h <- h_pred[k]
res_c <- NULL
test_idx <- (length(y) - h + 1):length(y)
obs_idx <- setdiff(seq_along(y), test_idx)
# AR
ar_base <- auto.arima(y[obs_idx],max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE, allowdrift = FALSE)
p1 <- max(1, ar_base$arma[1])
ar_fit <- arima(y[obs_idx], order = c(p1,0,0), include.mean = FALSE)
ar_prediction <- predict(ar_fit, n.ahead = h)$pred
res_c <- c(res_c, sqrt(mean((ar_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(ar_prediction) !=sign(y[test_idx])))
#random walk
mean_prediction <- rep(y[max(obs_idx)], length(test_idx))
res_c <- c(res_c, sqrt(mean((mean_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(mean_prediction) !=sign(y[test_idx])))
#Average
ave_prediction <- Average_prediction(y[obs_idx], length(test_idx))
res_c <- c(res_c, sqrt(mean((ave_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(ave_prediction) !=sign(y[test_idx])))
#AR + unemployment
ar_unem_base <- auto.arima(y[obs_idx], xreg = unem[obs_idx], max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE,      allowdrift = FALSE)
p1_un <- max(1, ar_unem_base$arma[1])
ar_unem_fit <- arima(y[obs_idx], xreg = unem[obs_idx], order = c(p1_un,0,0), include.mean = FALSE)
ar_unem_prediction <- predict(ar_unem_fit, newxreg = unem[test_idx], n.ahead = h)$pred
res_c <- c(res_c, sqrt(mean((ar_unem_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(ar_unem_prediction) !=sign(y[test_idx])))
#AR + LDA embedding
arx_fit <- arima(y[obs_idx], order = c(p1,0,0), xreg = X_m[obs_idx,strong_idx, drop = FALSE], include.mean = FALSE)
arx_predictions <- predict(arx_fit, n.ahead = h, newxreg = X_m[test_idx,strong_idx, drop = FALSE])$pred
res_c <- c(res_c, sqrt(mean((arx_predictions-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(arx_predictions) !=sign(y[test_idx])))
# AR + unem + LDA embedding
arx_unem_fit <- arima(y[obs_idx],order = c(p1,0,0), xreg = cbind(X_m[obs_idx,strong_idx, drop=FALSE],unem[obs_idx]), include.mean = FALSE)
arx_unem_predictions <- predict(arx_unem_fit, n.ahead=h, newxreg=cbind(X_m[test_idx,strong_idx,drop=FALSE],  unem[test_idx]))$pred
res_c <- c(res_c, sqrt(mean((arx_unem_predictions-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(arx_unem_predictions) !=sign(y[test_idx])))
# LLM powered: lag term + LDA embedding
p2=1
powered_prediction <- LLM_TS.Predict(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, strong_idx, h)
res_c <- c(res_c, sqrt(mean((powered_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(powered_prediction) !=sign(y[test_idx])))
# LLM powered: lag term + unem + LDA embedding
powered_unem_prediction <- LLM_TS.Predict(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx,
c(strong_idx,ncol(X_m)+1), h)
res_c <- c(res_c, sqrt(mean((powered_unem_prediction-y[test_idx])^2)))
res_c <- c(res_c, mean(sign(powered_unem_prediction) !=sign(y[test_idx])))
# TimeLLM (CPI only) - not available for WSJ yet
res_c <- c(res_c, NA_real_, NA_real_)
# PatchTST (CPI only) - not available for WSJ yet
res_c <- c(res_c, NA_real_, NA_real_)
Res_m[k,] <- res_c
}
LDA_mse <- Res_m[,seq(1, ncol(Res_m), 2)]
LDA_sign <- Res_m[,seq(2, ncol(Res_m), 2)]
colnames(LDA_mse) <- c('AR','RW','AVE','AR+unem','LDA','LDA+unem','LLM+LDA','LLM+LDA+unem',
'TimeLLM','PatchTST')
colnames(LDA_sign) <- c('AR','RW','AVE','AR+unem','LDA','LDA+unem','LLM+LDA','LLM+LDA+unem',
'TimeLLM','PatchTST')
MSE_without_unem <- LDA_mse[,c('AR','RW','AVE','LDA','LLM+LDA','TimeLLM','PatchTST')]
rMSE_without_unem <- sweep(MSE_without_unem, 1, MSE_without_unem[,'AR',drop=FALSE], "/")
rMSE_without_unem <- cbind(h_pred, rMSE_without_unem)
knitr::kable(rMSE_without_unem,col.names = c('H','AR','RW','AVE','LDA','LLM+LDA','TimeLLM','PatchTST'), digits = 3, caption = 'Cumulative rPMSE without unemployment rate')
colMeans(rMSE_without_unem[,-1, drop = FALSE])
Sign_without_unem <- LDA_sign[,c('AR','RW','AVE','LDA','LLM+LDA','TimeLLM','PatchTST')]
rSign_without_unem <- sweep(Sign_without_unem, 1, Sign_without_unem[,'AR',drop=FALSE], "/")
rSign_without_unem <- cbind(h_pred, rSign_without_unem)
knitr::kable(rSign_without_unem,col.names = c('H','AR','RW','AVE','LDA','LLM+LDA','TimeLLM','PatchTST'), digits = 3, caption = 'Cumulative rSign without unemployment rate')
colMeans(rSign_without_unem[,-1, drop = FALSE])
MSE_with_unem <- LDA_mse[,c('AR+unem','RW','AVE','LDA+unem','LLM+LDA+unem')]
rMSE_with_unem <- sweep(MSE_with_unem, 1, MSE_with_unem[,'AR+unem',drop=FALSE], "/")
rMSE_with_unem <- cbind(h_pred, rMSE_with_unem)
knitr::kable(rMSE_with_unem,col.names = c('H','AR+unem','RW','AVE','LDA+unem','LLM+LDA+unem'), digits = 3, caption = 'Cumulative rPMSE with unemployment rate')
colMeans(rMSE_with_unem[,-1, drop = FALSE])
Sign_with_unem <- LDA_sign[,c('AR+unem','RW','AVE','LDA+unem','LLM+LDA+unem')]
rSign_with_unem <- sweep(Sign_with_unem, 1, Sign_with_unem[,'AR+unem',drop=FALSE], "/")
rSign_with_unem <- cbind(h_pred, rSign_with_unem)
knitr::kable(rSign_with_unem,col.names = c('H','AR+unem','RW','AVE','LDA+unem','LLM+LDA+unem'), digits = 3, caption = 'Cumulative rSign with unemployment rate')
colMeans(rSign_with_unem[,-1, drop = FALSE])
