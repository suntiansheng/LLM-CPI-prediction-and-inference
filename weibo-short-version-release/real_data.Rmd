---
title: "Real Data Analysis"
date: "2025-06-09"
author: "Yingying Fan, Jinchi Lv, Ao Sun and Yurou Wang"
output:
  prettydoc::html_pretty:
    theme: hpstr
    highlight: github
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("./utility.R")
source("./SPI.R")
set.seed(1234)
library(dplyr)
library(forecast)
library(MTS)
library(lubridate)
library(expm)
```

## LLM-Powered Prediction with LDA Embedding 
```{r}
# read the LDA embedding dataset
df <- read.csv('./meanTopicDistri_mergeCPI100_Unemployment_df19-23_20250301.csv')
colnames(df)
```

### Data preprocessing
```{r}
topic_cols <- names(df)[grepl("^X\\d+$", names(df))]
df_new <- df %>%
  select(time, pred_scoreInflation, all_of(topic_cols), unem, cpi_lastmonth_100)
df_new$unem <- df[["unem"]] # unemployment rate
df_new$cpi <- df$cpi_lastmonth_100 # CPI index
df_new$time <- as.Date(df_new$time) # transfer variable ''time'' to Date type
df_new <- df_new %>%
  arrange(time) 

df_new <- df_new %>%
  mutate(
    month = format(time,"%Y-%m"),  # extract year and month
    day = day(time),                
    period = case_when(
      day <= 10 ~ "up",
      day <= 20 ~ "middle",
      TRUE ~ "down"
    )
  )


df_new <- df_new[,!names(df_new) %in% c("time")]

df_summary <- df_new %>%
  group_by(month, period) %>%
  summarise(across(everything(), mean, na.rm = TRUE))



y_m_list <- sort(unique(df_summary$month))
tilde_y_m <- matrix(ncol = 3, nrow = length(y_m_list))
for(i in 1:length(y_m_list)){
  res_ym <- y_m_list[i]
  tilde_y_m[i,] <- df_summary[df_summary$month == res_ym,]$pred_scoreInflation
}




X_m <- df_summary %>%
  group_by(month) %>%
  summarise(across(all_of(topic_cols), mean, na.rm = TRUE), .groups = "drop") %>%
  arrange(month) %>%
  select(-month) %>%
  as.matrix()
X_m[is.na(X_m)] <- 0


y_df <- df_new %>%
  group_by(month) %>%
  summarise(y = mean(cpi))
y = y_df$y
y = y-100
y = scale(y)

y_df <- df_new %>%
  group_by(month) %>%
  summarise(y = mean(unem))
unem = y_df$y
unem = scale(unem)
```

### Data analysis

#### Variable Selection via correlation pursuit
```{r}
set.seed(1234)
EOD = min(45, length(y)) # we use first 45 data points to select the important variables
strong_idx <- select_topics(y, X_m, EOD = EOD, add_one = TRUE)
strong_idx
```


#### Prediction
```{r}
set.seed(1234)
h_c <- seq(8,15,1)
res_pred <- try({
Res_m <- matrix(nrow = length(h_c), ncol = 16)
for(k in 1:length(h_c)){
  h <- h_c[k]
  res_c <- NULL
  test_idx <- (length(y)-h+1):length(y)
  obs_idx <- setdiff(1:length(y), test_idx)
  
  # AR
  ar_fit <- auto.arima(y[obs_idx],max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE, allowdrift = FALSE)
  ar_fit <- arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), include.mean = FALSE)
  ar_prediction <- predict(ar_fit, n.ahead = h)$pred
  res_c <- c(res_c, sqrt(mean((ar_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(ar_prediction) !=sign(y[test_idx])))
  
  #random walk
  mean_prediction <- rep(y[max(obs_idx)], length(test_idx))
  res_c <- c(res_c, sqrt(mean((mean_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(mean_prediction) !=sign(y[test_idx])))
  
  #Average 
  ave_prediction <- Average_prediction(y[obs_idx], length(test_idx))
  res_c <- c(res_c, sqrt(mean((ave_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(ave_prediction) !=sign(y[test_idx])))
  
  #AR + unemployment
  ar_unem_fit <- auto.arima(y[obs_idx], xreg = unem[obs_idx], max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE,      allowdrift = FALSE)
  ar_unem_fit <- arima(y[obs_idx], xreg = unem[obs_idx], order = c(ar_unem_fit$arma[1],0,0), include.mean = FALSE)
  ar_unem_prediction <- predict(ar_unem_fit, newxreg = unem[test_idx], n.ahead = h)$pred
  
  res_c <- c(res_c, sqrt(mean((ar_unem_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(ar_unem_prediction) !=sign(y[test_idx])))

   #AR + LDA embedding
  arx_fit <- arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = X_m[obs_idx,strong_idx], include.mean = FALSE)
  arx_predictions <- predict(arx_fit, n.ahead = h, newxreg = X_m[test_idx,strong_idx])$pred
  
  res_c <- c(res_c, sqrt(mean((arx_predictions-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(arx_predictions) !=sign(y[test_idx])))
  
  # AR + unem + LDA embedding
  arx_unem_fit <- arima(y[obs_idx],order = c(2,0,0), xreg = cbind(X_m[obs_idx,strong_idx, drop=FALSE],unem[obs_idx]),    include.mean = FALSE)
  arx_unem_predictions <-predict(arx_unem_fit, n.ahead=h, newxreg=cbind(X_m[test_idx,strong_idx,drop=FALSE],  unem[test_idx]))$pred

  res_c <- c(res_c, sqrt(mean((arx_unem_predictions-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(arx_unem_predictions) !=sign(y[test_idx])))

  # LLM powered: lag term + LDA embedding
  p1=ar_fit$arma[1]
  p2=1
  
  powered_prediction <- LLM_TS.Predict(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, strong_idx, h)

  res_c <- c(res_c, sqrt(mean((powered_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(powered_prediction) !=sign(y[test_idx])))
  
  # LLM powered: lag term + unem + LDA embedding
  powered_unem_prediction <- LLM_TS.Predict(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                              c(strong_idx,ncol(X_m)+1), h)

  
  res_c <- c(res_c, sqrt(mean((powered_unem_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(powered_unem_prediction) !=sign(y[test_idx])))
  Res_m[k,] <- res_c
}
Res_m
}, silent = TRUE)
if (inherits(res_pred, "try-error")) {
  Res_m <- matrix(NA, nrow = length(h_c), ncol = 16)
} else {
  Res_m <- res_pred
}
```

```{r}
LDA_mse <- Res_m[,c(1,3,5,7,9,11,13,15)]
LDA_sign <- Res_m[,c(2,4,6,8,10,12,14,16)]
colnames(LDA_mse) <- c('AR','RW','AVE','AR+unem','LDA','LDA+unem','LLM+LDA','LLM+LDA+unem')
colnames(LDA_sign) <- c('AR','RW','AVE','AR+unem','LDA','LDA+unem','LLM+LDA','LLM+LDA+unem')
```




### Prediction interval with LDA embedding
```{r}
set.seed(1234)
h_c <- seq(8,15,1)

res_pi <- try({
coverage_m <- matrix(0, nrow = length(h_c), ncol = 10)
len_m <- matrix(0, nrow = length(h_c), ncol = 10)

for(k in 1:length(h_c)){
  h <- h_c[k]
  
  test_idx <- (length(y)-h+1):length(y)
  obs_idx <- setdiff(1:length(y), test_idx)
  
  #AR 
  ar_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0),include.mean = FALSE)
  ar_predictions_fit <- forecast(ar_fit, h = length(test_idx))
  ar_interval <- cbind(ar_predictions_fit$lower[,2], ar_predictions_fit$upper[,2])
  len_m[k, 1] <- mean(as.numeric(ar_interval[,2] - ar_interval[,1]))
  coverage_m[k,1] <- mean(mapply(check_coverage, split(ar_interval, row(ar_interval)), y[test_idx]))
  
  #AR+unem
  ar_unem_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = unem[obs_idx], include.mean = FALSE)
  ar_unem_predictions_fit <- forecast(ar_unem_fit, h = length(test_idx), xreg = unem[test_idx])
  ar_unem_interval <- cbind(ar_unem_predictions_fit$lower[,2], ar_unem_predictions_fit$upper[,2])
  len_m[k, 2] <- mean(as.numeric(ar_unem_interval[,2] - ar_interval[,1]))
  coverage_m[k,2] <- mean(mapply(check_coverage, split(ar_unem_interval, row(ar_unem_interval)), y[test_idx]))
  
 
  
  #AR+LDA embedding
  
  arx_lda_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = X_m[obs_idx,strong_idx,drop = FALSE], include.mean = FALSE)
  arx_lda_predictions_fit <- forecast(arx_lda_fit, h = length(test_idx), xreg = X_m[test_idx,strong_idx,drop = FALSE])
  arx_lda_interval <- cbind(arx_lda_predictions_fit$lower[,2], arx_lda_predictions_fit$upper[,2])
  
  len_m[k,3] <- mean(arx_lda_interval[,2] - arx_lda_interval[,1])
  coverage_m[k,3] <- mean(mapply(check_coverage, split(arx_lda_interval, row(arx_lda_interval)), y[test_idx]))
  
  #AR+LDA + unem
   arx_lda_un_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = cbind(X_m[obs_idx,strong_idx, drop=FALSE], unem[obs_idx]), include.mean = FALSE)
  arx_lda_un_predictions_fit <- forecast(arx_lda_un_fit, h = length(test_idx), xreg = cbind(X_m[test_idx,strong_idx,drop=FALSE], unem[test_idx]))
  arx_lda_un_interval <- cbind(arx_lda_un_predictions_fit$lower[,2], arx_lda_un_predictions_fit$upper[,2])
  
  len_m[k,4] <- mean(arx_lda_un_interval[,2] - arx_lda_un_interval[,1])
  coverage_m[k,4] <- mean(mapply(check_coverage, split(arx_lda_un_interval, row(arx_lda_un_interval)), y[test_idx]))
  
  #Powered+AR+LDA
  p1=ar_fit$arma[1]
  p2=1
  powered_lda_interval <- LLM_TS.BJ(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                            strong_idx, h)$interval
  len_m[k,5] <- mean(powered_lda_interval[,2] - powered_lda_interval[,1])
  coverage_m[k,5] <- mean(mapply(check_coverage, split(powered_lda_interval, row(powered_lda_interval)), y[test_idx]))
  
  #Boot+AR+LDA
  boot_lda_interval <- LLM_TS.BOOT(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, strong_idx, h, B=1000)$interval
  
  len_m[k,6] <- mean(boot_lda_interval[,2] - boot_lda_interval[,1])
  coverage_m[k,6] <- mean(mapply(check_coverage, split(boot_lda_interval, row(boot_lda_interval)), y[test_idx]))
  
   #Powered+AR+LDA+unem

  powered_interval <- LLM_TS.BJ(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                    c(strong_idx,ncol(X_m)+1), h)$interval
  len_m[k,7] <- mean(powered_interval[,2] - powered_interval[,1])
  coverage_m[k,7] <- mean(mapply(check_coverage, split(powered_interval, row(powered_interval)), y[test_idx]))
  
  #Boot+AR+LDA+unem

  boot_interval <- LLM_TS.BOOT(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx, c(strong_idx,ncol(X_m)+1), h, B = 1000)$interval
   
  len_m[k,8] <- mean(boot_interval[,2] - boot_interval[,1])
  coverage_m[k,8] <- mean(mapply(check_coverage, split(boot_interval, row(boot_interval)), y[test_idx]))
}
list(coverage_m = coverage_m, len_m = len_m)
}, silent = TRUE)
if (inherits(res_pi, "try-error")) {
  coverage_m <- matrix(NA, nrow = length(h_c), ncol = 10)
  len_m <- matrix(NA, nrow = length(h_c), ncol = 10)
} else {
  coverage_m <- res_pi$coverage_m
  len_m <- res_pi$len_m
}

```

```{r}
spi_res <- spi_multi_horizon(
  y = y,
  X_m = X_m,
  tilde_y_m = tilde_y_m,
  strong_idx = strong_idx,
  h_vec = h_c,
  unem = unem,
  has_unem = TRUE,
  cal_frac = 0.2,
  alpha = 0.05,
  p2 = 1
)

coverage_m[,9] <- spi_res$coverage_without_unem
len_m[,9] <- spi_res$length_without_unem
coverage_m[,10] <- spi_res$coverage_with_unem
len_m[,10] <- spi_res$length_with_unem

LDA_cov <- coverage_m
colnames(LDA_cov) <- c('AR','AR+unem','LDA', 'LDA+unem', 'LLM+LDA(BJ)','LLM+LDA(Boot)','LLM+LDA(BJ)+unem','LLM+LDA(Boot)+unem','LLM+LDA(SPI)','LLM+LDA(SPI)+unem')
LDA_len <- len_m
colnames(LDA_len) <- c('AR','AR+unem','LDA', 'LDA+unem', 'LLM+LDA(BJ)','LLM+LDA(Boot)','LLM+LDA(BJ)+unem','LLM+LDA(Boot)+unem','LLM+LDA(SPI)','LLM+LDA(SPI)+unem')
```

`

## LLM-Powered Prediction with BERT embedding
```{r}
df <- read.csv('./meanTopicDistri_mergeCPI100_Unemployment_df19-23_20250301.csv')
df_trans <- read.csv('./meanVector_mergeCPI_df19-23_20250201.csv')
df <- df[order(df$time),]
df_trans <- df_trans[order(df_trans$time),]
```


```{r}
#df_trans$cpi <- df$cpi_lastmonth_100
#df_trans$unem <- df$X31个大城市城镇调查失业率...
#colnames(df_trans)
df_new <- df_trans[,c(1,771, 3:770)]
#df_new$unem <-df$全国城镇调查失业率...
#df_new$cpi <- df$cpi_lastmonth_100
df_new$time <- as.Date(df_new$time)
df_new <- df_new %>%
  arrange(time)

df_new <- df_new %>%
  mutate(
    month = format(time,"%Y-%m"),  # 提取年月
    day = day(time),                # 提取日
    period = case_when(
      day <= 10 ~ "up",
      day <= 20 ~ "middle",
      TRUE ~ "down"
    )
  )


df_new <- df_new[,!names(df_new) %in% c("time")]

df_summary <- df_new %>%
  group_by(month, period) %>%
  summarise(across(everything(), mean, na.rm = TRUE))


X_m <- matrix(ncol = 20, nrow = length(y_m_list))
for(i in 1:length(y_m_list)){
  res_ym <- y_m_list[i]
  X_m[i,] <- apply(df_summary[df_summary$month == res_ym,4:23],2,mean)
}
X_m <- scale(X_m, center = FALSE)
```


#### Variable Selection via correlation pursuit
```{r}
set.seed(1234)
EOD = 45 # we use first 45 data points to select the important variables
strong_idx <- select_topics(y, X_m, EOD = EOD, add_one = FALSE)
strong_idx
```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Simulated data (replace this with your actual data)
data <- sort(abs(cov(ar_fit$residuals, X_m[1:EOD,])))

# Create a data frame for ggplot2
data_df <- data.frame(
  Index = seq_along(data), # Create an index for each bar
  Value = data
)

# Identify the highest two bars
data_df$Highlight <- ifelse(data_df$Value %in% tail(sort(data_df$Value), 2), "Highlight", "Normal")

# Generate the barplot using ggplot2
barplot <- ggplot(data_df, aes(x = factor(Index), y = Value, fill = Highlight)) +
  geom_bar(stat = "identity", color = "black") + # Add bars with black borders
  scale_fill_manual(values = c("Normal" = "skyblue", "Highlight" = "orange")) + # Highlight colors
  labs(
    title = NULL,
    x = NULL,
    y = "Correlation"
  ) +
  theme_minimal(base_size = 14) + # Clean theme with base font size
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"), # Center and bold the title
    axis.text.x = element_text(angle = 90, hjust = 1), # Rotate x-axis labels
    legend.position = "none" # Remove legend
  )

# Print the barplot
print(barplot)
```

### Prediction
```{r}
set.seed(1234)
h_c <- seq(8,15,1)
Res_m <- matrix(nrow = length(h_c), ncol = 16)
for(k in 1:length(h_c)){
  h <- h_c[k]
  res_c <- NULL
  test_idx <- (length(y)-h+1):length(y)
  obs_idx <- setdiff(1:length(y), test_idx)
  
  # AR
  ar_fit <- auto.arima(y[obs_idx],max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE, allowdrift = FALSE)
  ar_fit <- arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), include.mean = FALSE)
  ar_prediction <- predict(ar_fit, n.ahead = h)$pred
  ar_mse <- mean((ar_prediction-y[test_idx])^2)
  ar_sign <- mean(sign(ar_prediction) !=sign(y[test_idx]))
  res_c <- c(res_c, sqrt(mean((ar_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(ar_prediction) !=sign(y[test_idx])))
  
  #random walk
  mean_prediction <- rep(y[max(obs_idx)], length(test_idx))
  res_c <- c(res_c, sqrt(mean((mean_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(mean_prediction) !=sign(y[test_idx])))
  
  #Average 
  ave_prediction <- Average_prediction(y[obs_idx], length(test_idx))
  res_c <- c(res_c, sqrt(mean((ave_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(ave_prediction) !=sign(y[test_idx])))
  
  #AR + unemployment
  ar_unem_fit <- auto.arima(y[obs_idx], xreg = unem[obs_idx], max.q = 0, D = 0,seasonal = FALSE, allowmean = FALSE,      allowdrift = FALSE)
  ar_unem_fit <- arima(y[obs_idx], xreg = unem[obs_idx], order = c(ar_unem_fit$arma[1],0,0), include.mean = FALSE)
  ar_unem_prediction <- predict(ar_unem_fit, newxreg = unem[test_idx], n.ahead = h)$pred
  
  res_c <- c(res_c, sqrt(mean((ar_unem_prediction-y[test_idx])^2)/ar_mse))
  res_c <- c(res_c, mean(sign(ar_unem_prediction) !=sign(y[test_idx]))/ar_sign)

  # AR + BERT embedding
  arx_fit <- arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = X_m[obs_idx,strong_idx], include.mean = FALSE)
  arx_predictions <- predict(arx_fit, n.ahead = h, newxreg = X_m[test_idx,strong_idx])$pred
  
  res_c <- c(res_c, sqrt(mean((arx_predictions-y[test_idx])^2)/ar_mse))
  res_c <- c(res_c, mean(sign(arx_predictions) !=sign(y[test_idx]))/ar_sign)
  
  # AR + unem + BERT embedding
  arx_unem_fit <- arima(y[obs_idx],order = c(2,0,0), xreg = cbind(X_m[obs_idx,strong_idx, drop=FALSE],unem[obs_idx]),    include.mean = FALSE)
  arx_unem_predictions <-predict(arx_unem_fit, n.ahead=h, newxreg=cbind(X_m[test_idx,strong_idx,drop=FALSE],  unem[test_idx]))$pred

  res_c <- c(res_c, sqrt(mean((arx_unem_predictions-y[test_idx])^2)/ar_mse))
  res_c <- c(res_c, mean(sign(arx_unem_predictions) !=sign(y[test_idx]))/ar_sign)

  # LLM powered: lag term + BERT embedding
  p1=ar_fit$arma[1]
  p2=1
  
  powered_prediction <- LLM_TS.Predict(X_m, y, scale(tilde_y_m), p1, p2, obs_idx, test_idx, strong_idx, h)

  res_c <- c(res_c, sqrt(mean((powered_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(powered_prediction) !=sign(y[test_idx])))
  
  # LLM powered: lag term + unem + BERT embedding
  powered_unem_prediction <- LLM_TS.Predict(cbind(X_m,unem), y, scale(tilde_y_m), p1, p2, obs_idx, test_idx, 
                                              c(strong_idx,ncol(X_m)+1), h)

  
  res_c <- c(res_c, sqrt(mean((powered_unem_prediction-y[test_idx])^2)))
  res_c <- c(res_c, mean(sign(powered_unem_prediction) !=sign(y[test_idx])))
  Res_m[k,] <- res_c
}

#colnames(Res_m) <- c('h','ar mse', 'ar sign', 'ar+unem mse', 'ar+unem sign', 'ar+LDA mse', 'ar+LDA sign', 'Power ar+LDA mse', 'Power ar+LDA sign', 'Power ar+unem+LDA mse','Power ar+unem+LDA sign')
#Res_m
#colMeans(Res_m)

#prediction_result <- rbind(Res_m, colMeans(Res_m))
#rownames(prediction_result) <- c(h_c,'Average')

#knitr::kable(prediction_result[,seq(1,ncol(prediction_result),by=2)], digits = 3,col.names = c('H', 'RW','Ave', 'AR+Unem', 'AR+LDA', 'AR+Unem+LDA','Powered LDA', 'Powered Unem+LDA'), caption = 'Prediction MSE with BERT embedding')
```

```{r}
BERT_mse <- Res_m[,c(1,3,5,7,9,11,13,15)]
BERT_sign <- Res_m[,c(2,4,6,8,10,12,14,16)]
colnames(BERT_mse) <- c('AR','RW','AVE','AR+unem','BERT','BERT+unem','LLM+BERT', 'LLM+BERT+unem')
colnames(BERT_sign) <- c('AR','RW','AVE','AR+unem','BERT','BERT+unem', 'LLM+BERT', 'LLM+BERT+unem')
```


```{r}
# knitr::kable(prediction_result[,seq(2,ncol(prediction_result),by=2)], digits = 3,col.names = c('H', 'RW','Ave', 'AR+Unem', 'AR+LDA', 'AR+Unem+LDA','Powered LDA', 'Powered Unem+LDA'), caption = 'Prediction sign error with BERT embedding')
```

### Prediction interval with BERT embedding
```{r}
set.seed(1234)
h_c <- seq(8,15,1)

coverage_m <- matrix(0, nrow = length(h_c), ncol = 8)
len_m <- matrix(0, nrow = length(h_c), ncol = 8)

for(k in 1:length(h_c)){
  h <- h_c[k]
  
  test_idx <- (length(y)-h+1):length(y)
  obs_idx <- setdiff(1:length(y), test_idx)
  
  #AR 
  ar_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0),include.mean = FALSE)
  ar_predictions_fit <- forecast(ar_fit, h = length(test_idx))
  ar_interval <- cbind(ar_predictions_fit$lower[,2], ar_predictions_fit$upper[,2])
  len_m[k, 1] <- mean(as.numeric(ar_interval[,2] - ar_interval[,1]))
  coverage_m[k,1] <- mean(mapply(check_coverage, split(ar_interval, row(ar_interval)), y[test_idx]))
  
  #AR+unem
  ar_unem_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = unem[obs_idx], include.mean = FALSE)
  ar_unem_predictions_fit <- forecast(ar_unem_fit, h = length(test_idx), xreg = unem[test_idx])
  ar_unem_interval <- cbind(ar_unem_predictions_fit$lower[,2], ar_unem_predictions_fit$upper[,2])
  len_m[k, 2] <- mean(as.numeric(ar_unem_interval[,2] - ar_interval[,1]))
  coverage_m[k,2] <- mean(mapply(check_coverage, split(ar_unem_interval, row(ar_unem_interval)), y[test_idx]))
  
 
  
  #AR+LDA embedding
  
  arx_BERT_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = X_m[obs_idx,strong_idx,drop = FALSE], include.mean = FALSE)
  arx_BERT_predictions_fit <- forecast(arx_BERT_fit, h = length(test_idx), xreg = X_m[test_idx,strong_idx,drop = FALSE])
  arx_BERT_interval <- cbind(arx_BERT_predictions_fit$lower[,2], arx_BERT_predictions_fit$upper[,2])
  
  len_m[k,3] <- mean(arx_BERT_interval[,2] - arx_BERT_interval[,1])
  coverage_m[k,3] <- mean(mapply(check_coverage, split(arx_BERT_interval, row(arx_BERT_interval)), y[test_idx]))
  
  #AR+BERT + unem
  arx_BERT_un_fit <- Arima(y[obs_idx], order = c(ar_fit$arma[1],0,0), xreg = cbind(X_m[obs_idx,strong_idx, drop=FALSE], unem[obs_idx]), include.mean = FALSE)
  arx_BERT_un_predictions_fit <- forecast(arx_BERT_un_fit, h = length(test_idx), xreg = cbind(X_m[test_idx,strong_idx,drop=FALSE], unem[test_idx]))
  arx_BERT_un_interval <- cbind(arx_BERT_un_predictions_fit$lower[,2], arx_BERT_un_predictions_fit$upper[,2])
  
  len_m[k,4] <- mean(arx_BERT_un_interval[,2] - arx_BERT_un_interval[,1])
  coverage_m[k,4] <- mean(mapply(check_coverage, split(arx_BERT_un_interval, row(arx_BERT_un_interval)), y[test_idx]))
  
  #Powered+AR+BERT
  p1=ar_fit$arma[1]
  p2=1
  powered_BERT_interval <- LLM_TS.BJ(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                            strong_idx, h)$interval
  len_m[k,5] <- mean(powered_BERT_interval[,2] - powered_BERT_interval[,1])
  coverage_m[k,5] <- mean(mapply(check_coverage, split(powered_BERT_interval, row(powered_BERT_interval)), y[test_idx]))
  
  #Boot+AR+BERT
  boot_BERT_interval <- LLM_TS.BOOT(X_m, y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                        strong_idx, h, B = 1000)$interval
  
  len_m[k,6] <- mean(boot_BERT_interval[,2] - boot_BERT_interval[,1])
  coverage_m[k,6] <- mean(mapply(check_coverage, split(boot_BERT_interval, row(boot_BERT_interval)), y[test_idx]))
  
   #Powered+AR+BERT+unem

  powered_interval <- LLM_TS.BJ(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                    c(strong_idx,ncol(X_m)+1), h)$interval
  len_m[k,7] <- mean(powered_interval[,2] - powered_interval[,1])
  coverage_m[k,7] <- mean(mapply(check_coverage, split(powered_interval, row(powered_interval)), y[test_idx]))
  
  #Boot+AR+BERT+unem

  boot_interval <- LLM_TS.BOOT(cbind(X_m,unem), y, tilde_y_m, p1, p2, obs_idx, test_idx, 
                                        c(strong_idx,ncol(X_m)+1), h, B = 1000)$interval
   
  len_m[k,8] <- mean(boot_interval[,2] - boot_interval[,1])
  coverage_m[k,8] <- mean(mapply(check_coverage, split(boot_interval, row(boot_interval)), y[test_idx]))
}



#rownames(coverage_m) <- h_c
#colnames(coverage_m) <- c('AR', 'AR+unem(U)', 'AR+unem(BERT)', 'AR+unem(BERT+U)', 'Pow(BERT)','Pow(U+BERT)', 'Boot(BERT)', 'Boot(U+BERT)')
#coverage_m <- rbind(coverage_m, colMeans(coverage_m))
#rownames(coverage_m) <- c(h_c,'Average')

#knitr::kable(coverage_m)
```


```{r}
BERT_cov <- coverage_m
colnames(BERT_cov) <- c('AR','AR+unem','BERT', 'BERT+unem', 'LLM+BERT(BJ)','LLM+BERT(Boot)','LLM+BERT(BJ)+unem','LLM+BERT(Boot)+unem')
BERT_len <- len_m
colnames(BERT_len) <- c('AR','AR+unem','BERT', 'BERT+unem', 'LLM+BERT(BJ)','LLM+BERT(Boot)','LLM+BERT(BJ)+unem','LLM+BERT(Boot)+unem')
```


## Prediction results

### Results without unemployment rate 
```{r}
MSE_without_unem <- cbind(LDA_mse[,c(1,2,3,5,7)], BERT_mse[,c(5,7),drop=FALSE])
MSE_without_unem <- MSE_without_unem[,c(1,2,3,4,6,5,7)]
rMSE_without_unem <- sweep(MSE_without_unem, 1, MSE_without_unem[,1,drop=FALSE], "/")
rMSE_without_unem <- cbind(h_c, rMSE_without_unem)
knitr::kable(rMSE_without_unem,col.names = c('H','AR','RW','AVE','LDA','BERT','LLM+LDA','LLM+BERT'), digits = 3, caption = 'rPMSE without unemployment rate')
colMeans(rMSE_without_unem)
```



```{r}
Sign_without_unem <- cbind(LDA_sign[,c(1,2,3,5,7)], BERT_sign[,c(5,7),drop=FALSE])
Sign_without_unem <- Sign_without_unem[,c(1,2,3,4,6,5,7)]
rSign_without_unem <- sweep(Sign_without_unem, 1, Sign_without_unem[,1,drop=FALSE], "/")
rSign_without_unem <- cbind(h_c, rSign_without_unem)
knitr::kable(rSign_without_unem,col.names = c('H','AR','RW','AVE','LDA','BERT','LLM+LDA', 'LLM+BERT'), digits = 3, caption = 'rSign without unemployment rate')
colMeans(rSign_without_unem)
```

### Results with unemployment rate 
```{r}
MSE_with_unem <- cbind(LDA_mse[,c(4,2,3,6,8)], BERT_mse[,c(6,8),drop=FALSE])
MSE_with_unem <- MSE_with_unem[,c(1,2,3,4,6,5,7)]
rMSE_with_unem <- sweep(MSE_with_unem, 1, MSE_with_unem[,1,drop=FALSE], "/")
rMSE_with_unem <- cbind(h_c, rMSE_with_unem)
knitr::kable(rMSE_with_unem,col.names = c('H','AR','RW','AVE','LDA','BERT','LLM+LDA','LLM+BERT'), digits = 3, caption = 'rPMSE with unemployment rate')
colMeans(rMSE_with_unem)
```


```{r}
Sign_with_unem <- cbind(LDA_sign[,c(4,2,3,6,8)], BERT_sign[,c(6,8),drop=FALSE])
Sign_with_unem <- Sign_with_unem[,c(1,2,3,4,6,5,7)]
rSign_with_unem <- sweep(Sign_with_unem, 1, Sign_with_unem[,1,drop=FALSE], "/")
rSign_with_unem <- cbind(h_c, rSign_with_unem)
knitr::kable(rSign_with_unem,col.names = c('H','AR','RW','AVE','LDA','BERT','LLM+LDA','LLM+BERT'), digits = 3, caption = 'rSign with unemployment rate')
colMeans(rSign_with_unem)
```


## Inference results

### Results without unemployment rate 
```{r}
Cov_without_unem <- cbind(LDA_cov[,c(1,3,5,6,9)], BERT_cov[,c(3,5,6)])
Cov_without_unem <- Cov_without_unem[,c(1,2,6,3,4,5,7,8)]
Cov_without_unem <- cbind(h_c, Cov_without_unem)
knitr::kable(Cov_without_unem, col.names = c('H','AR','LDA','BERT','LLM+LDA(BJ)','LLM+LDA(Boot)','LLM+LDA(SPI)','LLM+BERT(BJ)','LLM+BERT(Boot)'), digits = 3, caption = 'Coverage rate without unemployment rate')
colMeans(Cov_without_unem[,-1, drop = FALSE], na.rm = TRUE)
```


```{r}
Len_without_unem <- cbind(LDA_len[,c(1,3,5,6,9)], BERT_len[,c(3,5,6)])
Len_without_unem <- Len_without_unem[,c(1,2,6,3,4,5,7,8)]
Len_without_unem <- cbind(h_c, Len_without_unem)
knitr::kable(Len_without_unem, col.names = c('H','AR','LDA','BERT','LLM+LDA(BJ)','LLM+LDA(Boot)','LLM+LDA(SPI)','LLM+BERT(BJ)','LLM+BERT(Boot)'), digits = 3, caption = 'Interval length without unemployment rate')
colMeans(Len_without_unem[,-1, drop = FALSE], na.rm = TRUE)
```

### Results with unemployment rate 
```{r}
Cov_with_unem <- cbind(LDA_cov[,c(2,4,7,8,10)], BERT_cov[,c(4,7,8)])
Cov_with_unem <- Cov_with_unem[,c(1,2,6,3,4,5,7,8)] 
Cov_with_unem <- cbind(h_c, Cov_with_unem)
knitr::kable(Cov_with_unem, col.names = c('H','AR+unem','LDA+unem','BERT+unem','LLM+LDA(BJ)+unem','LLM+LDA(Boot)+unem','LLM+LDA(SPI)+unem','LLM+BERT(BJ)+unem','LLM+BERT(Boot)+unem'), digits = 3, caption = 'Coverage rate with unemployment rate')
colMeans(Cov_with_unem[,-1, drop = FALSE], na.rm = TRUE)
```

```{r}
Len_with_unem <- cbind(LDA_len[,c(2,4,7,8,10)], BERT_len[,c(4,7,8)])
Len_with_unem <- Len_with_unem[,c(1,2,6,3,4,5,7,8)]
Len_with_unem <- cbind(h_c, Len_with_unem)
knitr::kable(Len_with_unem, col.names = c('H','AR+unem','LDA+unem','BERT+unem','LLM+LDA(BJ)+unem','LLM+LDA(Boot)+unem','LLM+LDA(SPI)+unem','LLM+BERT(BJ)+unem','LLM+BERT(Boot)+unem'), digits = 3, caption = 'Interval length with unemployment rate')
colMeans(Len_with_unem[,-1, drop = FALSE], na.rm = TRUE)
```
